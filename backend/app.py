from flask import Flask, jsonify  # Removed request as it's not used yet
from flask_cors import CORS  # For handling cross-origin requests
import base64
import traceback  # For more detailed error logging

# Import our custom modules
from story_generator import get_random_genre, generate_story_from_bedrock
from polly_handler import synthesize_speech_with_polly

# We are not using ssml_generator directly as story_generator produces SSML

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes by default


@app.route("/api/generate_story", methods=["GET"])  # Changed to GET for simplicity now
def handle_generate_story():
    """
    Endpoint to generate a story, synthesize speech, and return data.
    """
    try:
        # 1. Get Genre
        genre = get_random_genre()
        if not genre:
            print("Error: Could not get random genre.")
            return jsonify({"error": "Failed to select story genre."}), 500
        print(f"Selected genre: {genre}")

        # 2. Generate Story SSML from Bedrock (Claude)
        ssml_text = generate_story_from_bedrock(genre)
        if not ssml_text:
            msg = f"Error: Failed to generate SSML for genre: {genre}"
            print(msg)
            return jsonify({"error": "Failed to generate story from LLM."}), 500
        # print(f"Generated SSML: {ssml_text[:200]}...") # For debugging

        # 3. Synthesize with Polly and get audio data + speech marks
        # The output_filename argument in synthesize_speech_with_polly is not used
        # when we are directly handling the audio_data here.
        audio_data, speech_marks = synthesize_speech_with_polly(ssml_text)

        if not audio_data or not speech_marks:
            err_msg = "Failed to synthesize or get marks from Polly."
            print(f"Error: {err_msg}")
            return jsonify({"error": "Failed to process story with Polly."}), 500

        # 4. Encode audio data to Base64
        # The frontend will expect audio in a format it can use, e.g., a data URI.
        # Prepending "data:audio/mp3;base64," is done on the frontend typically.
        audio_base64 = base64.b64encode(audio_data).decode("utf-8")
        print(f"Audio data encoded, b64 length: {len(audio_base64)}")

        response_data = {
            "genre": genre,
            "ssml_text": ssml_text,  # The SSML generated by Bedrock
            "audio_base64": audio_base64,  # Base64 encoded MP3 data
            "speech_marks": speech_marks,
        }
        return jsonify(response_data), 200

    except Exception as e:
        # Log the exception for debugging
        print(f"Critical Error in /api/generate_story: {e}")
        traceback.print_exc()  # Provides full traceback for server-side debugging
        return jsonify({"error": "Unexpected server error."}), 500


if __name__ == "__main__":
    # Note: For development, debug=True is fine. For production, use a proper WSGI server.
    # Ensure that AWS credentials and region are set in your environment.
    # Also, CLAUDE_MODEL_ID can be set if you want to override the default.
    print("Starting Flask backend for story generation...")
    print("Set AWS creds, region, & optionally CLAUDE_MODEL_ID.")
    print(
        "Virtual environment (.hackenv) should be active with requirements installed."
    )
    app.run(debug=True, port=5001)
